#lang racket
(provide (all-defined-out))

;;; Code that accompanies ``The Reasoned Schemer''
;;; Daniel P. Friedman, William E. Byrd and Oleg Kiselyov
;;; MIT Press, Cambridge, MA, 2005 
;;;
;;; The implementation of the logic system used in the (2nd printing) of
;;; the book.  

;;; This file was generated by writeminikanren.pl
;;; Generated at 2006-02-01 18:26:02

(define-syntax lambdag@
  (syntax-rules ()
    ((_ (s) e) (lambda (s) e))))

(define-syntax lambdaf@
  (syntax-rules ()
    ((_ () e) (lambda () e))))

(define-syntax rhs
  (syntax-rules ()
    ((rhs p) (cdr p))))

(define-syntax lhs
  (syntax-rules ()
    ((lhs p) (car p))))

(define-syntax var
  (syntax-rules ()
    ((var w) (vector w))))

(define-syntax var?
  (syntax-rules ()
    ((var? w) (vector? w))))

(define-syntax size-s
  (syntax-rules ()
    ((size-s ls) (length ls))))

(define empty-s '())

(define walk
  (lambda (v s)
    (cond
      ((var? v)
       (cond
         ((assq v s) =>
                     (lambda (a)
                       (let ((v^ (rhs a)))
                         (walk v^ s))))
         (else v)))
      (else v))))


(define ext-s
  (lambda (x v s)
    (cons `(,x . ,v) s)))

(define unify
  (lambda (v w s)
    (let ((v (walk v s))
          (w (walk w s)))
      (cond
        ((eq? v w) s)
        ((var? v) (ext-s v w s))
        ((var? w) (ext-s w v s))
        ((and (pair? v) (pair? w))
         (cond
           ((unify (car v) (car w) s) =>
                                      (lambda (s)
                                        (unify (cdr v) (cdr w) s)))
           (else #f)))
        ((equal? v w) s)
        (else #f)))))

(define ext-s-check
  (lambda (x v s)
    (cond
      ((occurs-check x v s) #f)
      (else (ext-s x v s)))))

(define occurs-check
  (lambda (x v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) (eq? v x))
        ((pair? v) 
         (or 
          (occurs-check x (car v) s)
          (occurs-check x (cdr v) s)))
        (else #f)))))

(define unify-check
  (lambda (v w s)
    (let ((v (walk v s))
          (w (walk w s)))
      (cond
        ((eq? v w) s)
        ((var? v) (ext-s-check v w s))
        ((var? w) (ext-s-check w v s))
        ((and (pair? v) (pair? w))
         (cond
           ((unify-check (car v) (car w) s) =>
                                            (lambda (s)
                                              (unify-check (cdr v) (cdr w) s)))
           (else #f)))
        ((equal? v w) s)
        (else #f)))))

(define walk*
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) v)
        ((pair? v)
         (cons
             (walk* (car v) s)
           (walk* (cdr v) s)))
        (else v)))))

(define reify-s
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) (ext-s v (reify-name (size-s s)) s))
        ((pair? v) (reify-s (cdr v) (reify-s (car v) s)))
        (else s)))))

(define reify-name
  (lambda (n)
    (string->symbol
     (string-append "_" "." (number->string n)))))

(define reify
  (lambda (v)
    (walk* v (reify-s v empty-s))))

(define-syntax run  
  (syntax-rules ()
    ((_ n^ (x) g ...)
     (let ((n n^)
           (x (var 'x)))
       (if (or (not n) (> n 0))
           (map-inf n
                    (lambda (s) (reify (walk* x s)))
                    ((all g ...) empty-s))
           '())))))

(define-syntax case-inf
  (syntax-rules ()
    ((_ e on-zero ((a^) on-one) ((a f) on-choice))
     (let ((a-inf e))
       (cond
         ((not a-inf) on-zero)
         ((not (and 
                (pair? a-inf)
                (procedure? (cdr a-inf))))
          (let ((a^ a-inf))
            on-one))
         (else (let ((a (car a-inf))
                     (f (cdr a-inf)))
                 on-choice)))))))

(define-syntax mzero
  (syntax-rules ()
    ((_) #f)))

(define-syntax unit
  (syntax-rules ()
    ((_ a) a)))

(define-syntax choice 
  (syntax-rules ()
    ((_ a f) (cons a f))))

(define map-inf
  (lambda (n p a-inf)
    (case-inf a-inf
              '()
              ((a) 
               (cons (p a) '()))
              ((a f) 
               (cons (p a)
                 (cond
                   ((not n) (map-inf n p (f)))
                   ((> n 1) (map-inf (- n 1) p (f)))
                   (else '())))))))

(define == 
  (lambda (v w)
    (lambdag@ (s)
              (cond
                ((unify v w s) => succeed)
                (else (fail s))))))

(define ==-check
  (lambda (v w)
    (lambdag@ (s)
              (cond
                ((unify-check v w s) => succeed)
                (else (fail s))))))

(define-syntax fresh 
  (syntax-rules ()
    ((_ (x ...) g ...)
     (lambdag@ (s)
               (let ((x (var 'x)) ...)
                 ((all g ...) s))))))

(define-syntax all
  (syntax-rules ()
    ((_) succeed)
    ((_ g) (lambdag@ (s) (g s))) ; 这里其实可以被eta reduce
    ((_ g^ g ...) (lambdag@ (s) (bind (g^ s) ; 如果g^ fail, i.e (g^ s)返回(mzero)，则后续的g short-circuting
                                      (all g ...))))))

(define-syntax conde
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g0 g ...)) (all g0 g ...))
    ((_ (g0 g ...) c ...)
     (anye (all g0 g ...) (conde c ...)))))

(define succeed (lambdag@ (s) (unit s)))

(define fail (lambdag@ (s) (mzero)))

;; 类似list的非确定性列表推导
;; 整个过程类似flatmap, map后flatten(用append 即mplus)
;; 本质上是深度遍历
(define bind
  (lambda (a-inf g)
    (case-inf a-inf
              (mzero) ; short-circuting
              ((a) (g a))
              ((a f) (mplus (g a) ; 这里类似list append, 这里返回多值(i.e. which也是一个stream)，然后通过mplus append 2个 stream
                            (lambdaf@ () (bind (f) g)))))))

;; mplus 类似 list append
;; a-inf的elements总在f的elements前面
(define mplus
  (lambda (a-inf f)
    (case-inf a-inf
              (f) ; 注意：如果a-inf是emppty，则会进一步求值f，换句话说mplus是严格的，它会严格求值只记到result stream非空
              ((a) (choice a f))
              ((a f0) (choice a 
                              (lambdaf@ () (mplus (f0) f)))))))

(define-syntax anye
  (syntax-rules ()
    ((_ g1 g2) 
     (lambdag@ (s)
               (mplus (g1 s) 
                      (lambdaf@ () (g2 s)))))))

(define-syntax alli
  (syntax-rules ()
    ((_) succeed)
    ((_ g) (lambdag@ (s) (g s)))
    ((_ g^ g ...) 
     (lambdag@ (s) 
               (bindi (g^ s) (alli g ...))))))

(define-syntax condi
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g0 g ...)) (all g0 g ...))
    ((_ (g0 g ...) c ...)
     (anyi (all g0 g ...) (condi c ...)))))

(define-syntax anyi
  (syntax-rules ()
    ((_ g1 g2) 
     (lambdag@ (s) 
               (mplusi (g1 s) 
                       (lambdaf@ () (g2 s)))))))

;; 类似list的非确定性列表推导
;; 语义上，整个过程仍然类似flatmap, map后flatten(用append 即mplus)
;; 但由于使用了mplusi来进行flatten而不是append，因此不是深度遍历
;; 一个例子是 1ed p.83
;; (alli
;;  (conde
;;   ((== #f q) succeed)
;;   (else (== #t q)))                    
;;  alwayso)
;; 这个例子里
;; conde产生两个元素的stream即使a-inf, g是alwayso
;; 这里mplusi很像把g map到 a-inf的两个元素，然后append
;; 但是这里不是mplus，而是mplusi，因此
;; 第一次map 即(g a)的result stream并不是和第二个map的result stream append在一起
;; 而是第一个result stream的头，第二个result stream的头，第一个result stream的第二个头，第二个reuslt stream的第二个头。。。这样交错
(define bindi
  (lambda (a-inf g) ; 这个g可能是一个alwayso
    (case-inf a-inf
              (mzero)
              ((a) (g a))
              ((a f) (mplusi (g a)  ; 这里用了mplusi
                             (lambdaf@ () (bindi (f) g)))))))

;; mplus 类似 list append
;; 但是a-inf的elements只有第一个元素在a-inf前面，之后的元素在f的elements后面
;; 注意：这里的a-inf可能是一个alwayso产生的substituion stream，see 1ed p.83
;; 换句话说，这里alwayso只会用一个头，然后后续是f which is next value of conde，也就是上面bindi里a-inf里后续subst
;; 因此，alli里的第一个clause和第二个clause交错！
(define mplusi
  (lambda (a-inf f)
    (case-inf a-inf
              (f) 
              ((a) (choice a f))
              ((a f0) (choice a 
                              (lambdaf@ () (mplusi (f) f0))))))) ; 和mplus的区别是，mplus这里是 (mplus (f0) f)

(define-syntax conda
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g0 g ...)) (all g0 g ...))
    ((_ (g0 g ...) c ...)
     (ifa g0 (all g ...) (conda c ...)))))

(define-syntax condu
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g0 g ...)) (all g0 g ...))
    ((_ (g0 g ...) c ...)
     (ifu g0 (all g ...) (condu c ...)))))

;; 注意g0 g1是在同一个clause line里的
(define-syntax ifa
  (syntax-rules ()
    ((_ g0 g1 g2)
     (lambdag@ (s)
               (let ((s-inf (g0 s))
                     (g^ g1))
                 (case-inf s-inf
                           (g2 s) ; 当g0失败，才会走这里的g2（也就是remain clauses of conda），注意：g0的subst不会保留，仍然用s
                           ((s) (g^ s)) ; 当g0成功 with one subst, 则g0的subst effect会保留，这里的s是新的s
                           ((s f) (bind s-inf g^)))))))) ; 当g0成功 with multi substs, 则g0的subst effect会保留，s-inf是新的s-inf

;; 注意g0 g1是在同一个clause line里的
(define-syntax ifu
  (syntax-rules ()
    ((_ g0 g1 g2)
     (lambdag@ (s)
               (let ((s-inf (g0 s))
                     (g^ g1))
                 (case-inf s-inf
                           (g2 s) ; 当g0失败，才会走这里的g2（也就是remain clauses of condu），注意：g0的subst不会保留，仍然用s
                           ((s) (g^ s)) ; 当g0成功 with one subst,  则g0的subst effect会保留，这里的s是新的s
                           ((s f) (g^ s)))))))) ; 当g0成功 with multi substs，则g0的subst effect会保留，s-inf是新的s-inf，但是condu只取第一个substituion跑该clause line里的后续g1

;; 换句话说，condu的unique只对question起作用!
;; 当question成功时，只取question的result substs里的第一个subst作为后续的s



;; p.159
;; whereas conda leaves the stream produced by g0 intact.
;; 换句话说，conda的意思是只使用condu第一个成功clause，并忽略其他clause

;; condu chops off every substitution after the first produced by g0
;; 换句话说，condu的u尽管解释为unique，但它的意思是只使用condu第一个成功clause的里的第一个substition执行后续，并忽略其他clause
;; 而不是说第一个成功clause的里的每一个substition里使该clause里后续成功的第一个substition！

