#lang racket
(require "mk.rkt")
(provide (all-defined-out))

;;; Code that accompanies ``The Reasoned Schemer''
;;; Daniel P. Friedman, William E. Byrd and Oleg Kiselyov
;;; MIT Press, Cambridge, MA, 2005
;;;
;;; Extra forms appearing in the framenotes of the book.
;;;
;;; run* is a convenient macro (see frame 10 on page 4 of chapter 1)
;;; (run* (q) ...) is identical to (run #f (q) ...)
;;; See frame 40 on page 68 of chapter 5 for a description of 'lambda-limited'.
;;; See frame 47 on page 138 of chapter 9 for a description of 'project'.
;;;
;;; This file was generated by writeminikanren.pl
;;; Generated at 2005-08-12 11:27:16

(define-syntax run*
  (syntax-rules ()
    ((_ (x) g ...) (run #f (x) g ...))))

(define-syntax lambda-limited
  (syntax-rules ()
    ((_ n formals g)                                          
     (let ((x (var 'x)))                                               
       (lambda formals   ;; 注意：在lambda-limited body里（也就是g里）引用define swappendo自身,实际上引用的是这个lambda！
         (ll n x g)))))) ;; 因此这样的递归调用会使用同一个x，于是这个x在substituion里就可以作为累积变量使用！ 
;; 因此，如果你定义
;; (define swappendo
;;   (lambda-limited 5 (l s out)
;;                   (conde
;;                    (succeed
;;                     (fresh (a d res)
;;                            (conso a d l)
;;                            (conso a res out)
;;                            (swappendo d s res)))
;;                    (else (nullo l) (== s out)))))
;; 则这里的5表示swappendo递归了5次之后stop!
;; 这非常amazing！

(define ll
  (lambda (n x g)
    (lambdag@ (s)
      (let ((v (walk x s)))
        (cond
          ((var? v) (g (ext-s x 1 s)))
          ((< v n) #;(printf "s=~v\n" s)
                   #;(printf "x=~v\n" (walk* x s))
                   (g (ext-s x (+ v 1) s)))
          (else (fail s)))))))

(define-syntax project 
  (syntax-rules ()
    ((_ (x ...) g ...)  
     (lambdag@ (s)
       (let ((x (walk* x s)) ...)
         ((all g ...) s))))))
